Домашнее задание 2
================
Алла Тамбовцева

Формат сдачи
------------

*Срок сдачи:*

29 сентября 2017, 22:00

*Формат сдачи:*

Студенту необходимо на выбор выполнить задачи базового или продвинутого блока. Результат выполнения домашнего задания 2: файл с расширением `.R`. Этот файл нужно загрузить по [ссылке](https://www.dropbox.com/request/NypiSwPi5drEhF76jMXB).

Базовый блок
------------

Скачайте с GitHub файл `hw2-rcode.R`, переименуйте его `hw2-rcode-surname.R`, где `surname` - Ваша фамилия латиницей. Откройте этот файл в R - в него Вы будете вписывать код для задач.

**Задача 1**

*Примечание: 1) Все совпадения имен считать случайными. 2) С автором задачи точно все хорошо.*

В одном из районов города Рэндомвилль страны R-пландии накануне выборов в органы местного самоуправления был проведен опрос 100 жителей с целью выяснить, какую поддержку имеют кандидаты. В опросе респонденты могут указывать любое количество кандидатов, которых они собираются поддержать на выборах (всего в выборах участвуют 10 кандидатов).

Перед вами три вектора, которые представляют собой набор id респондентов, которые поддерживают следующих кандидатов:

-   Поликарп Монте-Карлович (вектор p)
-   Матвей Регрессович (вектор m)
-   Ядвига Эпсилоновна (вектор y)

``` r
set.seed(1234) # чтобы у всех были одинаковые результаты
p <- sample(1:100, size = 60) # 60 человек указали Поликарпа в качестве кандидата, 
# которого хотят поддержать на выборах
m <- sample(1:100, size = 50)
y <- sample(1:100, size = 70)
```

Векторы не содержат повторяющихся значений.

1.  Выведите на экран id респондентов, которые одновременно поддерживают всех трех кандидатов. Сколько таких респондентов?
2.  Выведите на экран id респондентов, которые поддерживают Поликарпа Монте-Карловича, но не поддерживают Матвея Регрессовича. Выведите на экран id респондентов, которые поддерживают Матвея Регрессовича, но не поддерживают Поликарпа Монте-Карловича. Каких респондентов больше?
3.  Выведите на экран id респондентов, которые поддерживают только Ядвигу Эпсилоновну и больше никого.
4.  *(Не оценивается, пункт за плюсик в карму)*. Придумайте, соблюдая "стилистику" задачи, имена остальным семи кандидатам.

*Подсказка из теории множеств:* 

![equation](https://www.codecogs.com/eqnedit.php?latex=A&space;\cap&space;B&space;\cap&space;C&space;=&space;A&space;\cap&space;(B&space;\cap&space;C)&space;=&space;(A&space;\cap&space;B)&space;\cap&space;C)


**Задача 2**

1.  Создайте матрицу E размерности 4 \* 5, заполненную пропущенными значениями (NA). Замените некоторые ее элементы, чтобы получить такую матрицу:

<!-- -->

    ##      [,1] [,2] [,3] [,4] [,5]
    ## [1,]    1   NA   NA    3    1
    ## [2,]   NA   NA    6    0   NA
    ## [3,]    5    7    9    0   NA
    ## [4,]   NA    2   NA   NA   NA

2.  С помощью функции `as.vector()` превратите полученную матрицу E в вектор и выведите на экран индексы пропущенных значений.

**Задача 3**

Дана матрица M

(*happiness* - индекс счастья, [World Happiness Report 2017](http://worldhappiness.report/ed/2017/). *gdp* - [ВВП](https://data.worldbank.org/data-catalog/GDP-ranking-table) в миллионах долларов в 2017 году):

``` r
happiness <- c(6.442, 6.442, 5.835, 5.856, 5.245, 6.635, 7.498, 5.977, 6.572, 6.705)
gdp <- c(2465454, 3466757, 469509, 1283162, 11199145,1796187, 370557, 1849970, 296966, 247028)
M <- cbind(happiness, gdp)
M
```

    ##       happiness      gdp
    ##  [1,]     6.442  2465454
    ##  [2,]     6.442  3466757
    ##  [3,]     5.835   469509
    ##  [4,]     5.856  1283162
    ##  [5,]     5.245 11199145
    ##  [6,]     6.635  1796187
    ##  [7,]     7.498   370557
    ##  [8,]     5.977  1849970
    ##  [9,]     6.572   296966
    ## [10,]     6.705   247028

1.  Создайте вектор с названиями стран: France, Germany, Poland, Russia, China, Brazil, Norway, Italy, Singapore, Chile. Назовите строки матрицы M в соответствии с этим вектором.
2.  Добавьте в матрицу столбец log\_gdp, который содержит значения натурального логарифма ВВП для стран в матрице M.
3.  Добавьте в матрицу M строку с данными по Португалии: `happiness = 5.195, gdp = 204565, log_gdp = 12.22864`. Не забудьде назвать строку Portugal.
4.  Определите размерность обновленной матрицы M.

**Задача 4**

*Напоминание про корреляции.* Коэффициент корреляции К.Пирсона -- показатель линейной связи между двумя переменными, измеренными в количественной шкале. Коэффициент корреляции принимает значения от -1 до 1. Отрицательные значения коэффициента корреляции свидетельствуют об обратной связи между переменными (с ростом значений одной переменной значения другой переменной уменьшаются), положительные значения коэффициента корреляции -- о прямой связи между переменными (с ростом значений одной переменной значения другой переменной увеличиваются). Если коэффициент корреляции Пирсона между переменными равен 0, это не всегда означает, что связи между ними нет -- связь между ними может просто быть нелинейной (например, квадратичной). Коэффициент корреляции показывает только связь между переменными, а не зависимость (Y зависит от X) и не влияние (X влияет на Y).

Связи между количественными переменными можно представить в виде корреляционной матрицы. Корреляционная матрица всегда симметрична (коэффициент корреляции между переменными X и Y равен коэффициенту корреляции между переменными Y и X), и на главной диагонали такой матрицы стоят 1 (корреляция переменной самой с собой равна 1).

*Пример.* Есть три переменные X, Y и Z. Известны коэффициенты корреляции Corr(X,Y) = 0.3, Corr(X,Z) = 0.4, Corr(Y,Z) = 0.1. Корреляционная матрица выглядит следующим образом:

    ##     X   Y   Z
    ## X 1.0 0.3 0.4
    ## Y 0.3 1.0 0.1
    ## Z 0.4 0.1 1.0

*Задание:*

Даны четыре количественные переменные: V, W, U, Q.

Известно, что Corr(V,W) = 0.1, Corr(V,U) = 0.2, Corr(V,Q) = 0.8, Corr(W,U) = 0.3, Corr(W,Q) = 0.4, Corr(U,Q) = 0.5.

Создайте любым способом корреляционную матрицу C. Назовите столбцы и строки в соответствии с именами переменных (как в примере выше).

**Задача 5**

Используя код, обсуждавшийся на лекции и на семинаре 1, сгенерируйте следующие векторы:

-   вектор *index1*, который содержит 20 значений от 0.5 до 10 (0.5, 1, 1.5, ..., 9.5, 10)
-   вектор *index2*, который содержит 20 значений от 1 до 20 (1, 2, 3, ..., 18, 19, 20)
-   вектор *index3*, который содержит 30 значений (повторяющиеся значения есть), взятых (псевдо)случайным образом из последовательности значений от 5 до 35 с шагом 5 (не потеряйте строчку кода, которая обеспечивает воспроизводимость результатов -- чтобы при "выдергивании" значений из последовательности у всех получались одинаковые векторы)
-   вектор *index4*, который содержит повторенный 4 раза набор значений (2, 3, 7).

1.  Создайте из полученных векторов список L. Элементы списка должны иметь названия, совпадающие с названием векторов.
2.  Выведите на экран третий элемент последнего вектора в списке. Замените его на пропущенное значение.

**Задача 6**

Напишите код, который позволяет проверить, есть ли в векторе повторяющиеся значения: если есть, то на экран должно выводиться TRUE, если нет, то FALSE.

Например, для вектора z

``` r
z <- c(1, 1, 5, 6, 7, 8, 9, 10, 11, 10, 12, 8, 8, 1, 0)
```

результат должен быть такой:

    ## [1] TRUE

Использовать встроенные функции для поиска дубликатов (как `duplicate()`) нельзя! Для выполнения этого задания знакомство с операторами условия и циклами *не требуется*.

*Подсказка:* функцию для поиска дубликатов использовать нельзя, но про функцию для поиска уникальных значений никто ничего не говорил.

Продвинутый блок
----------------

Сохраните код для задания в файле `hw2-adv-surname.R`, где `surname` - Ваша фамилия латиницей.

**Задание**

Напишите функцию `fcorrs()`, которая принимает на вход параметры

-   `n_obs` (число наблюдений)
-   `mean_vect` (вектор средних значений)
-   `corr_vect` (вектор коэффициентов корреляции между переменными)

и выдает матрицу, столбцы которой являются нормально распределенными переменными, средние значения которых равны значениям из вектора `mean_vect`, и которые скоррелированы друг с другом в соответствии со значениями коэффициентов корреляции из вектора `corr_vect`.

*Подсказка.* Вам понадобится функция `mvrnorm()` из библиотеки MASS.

*Пример*. Нужно создать матрицу из трех нормально распределенных переменных V1, V2 и V3, таких, что среднее значение V1 равно 1, среднее значение V2 равно 2, среднее значение V3 равно 3 и Corr(V1, V2) = 0.3, Corr(V1, V3) = 0.6, Corr(V2, V3) = 0.8.

``` r
# входные данные

n = 100
my_means = c(1, 2, 3)
my_corrs <- c(0.3, 0.6, 0.8)
```

``` r
# функция и ее вывод

M <- fcorrs(n_obs = n, means_vect = my_means, corrs_vect = my_corrs)
head(M)
```

    ##            [,1]      [,2]      [,3]
    ## [1,]  1.1671382 1.1397532 2.8107346
    ## [2,]  3.1760701 2.1983994 4.9081009
    ## [3,]  2.9798006 3.7932459 4.6263823
    ## [4,]  1.4008963 2.5409431 3.0599134
    ## [5,] -1.1826554 0.1618920 0.5489593
    ## [6,]  0.5325931 0.2066273 1.4986835

``` r
# проверка нужных характеристик

mean(M[, 1]); mean(M[, 2]); mean(M[, 3]) # средние
```

    ## [1] 1

    ## [1] 2

    ## [1] 3

``` r
cor(M[, 1], M[, 2]); cor(M[, 1], M[, 3]); cor(M[, 2], M[, 3]) # коэффициенты корреляции
```

    ## [1] 0.3

    ## [1] 0.6

    ## [1] 0.8

``` r
shapiro.test(M[, 1]); shapiro.test(M[, 2]); shapiro.test(M[, 3]) # нормальное распределение
```

    ## 
    ##  Shapiro-Wilk normality test
    ## 
    ## data:  M[, 1]
    ## W = 0.99562, p-value = 0.9879

    ## 
    ##  Shapiro-Wilk normality test
    ## 
    ## data:  M[, 2]
    ## W = 0.98316, p-value = 0.2324

    ## 
    ##  Shapiro-Wilk normality test
    ## 
    ## data:  M[, 3]
    ## W = 0.98258, p-value = 0.2099

**Базовый вариант (на 7-8 баллов).** Написать указанную выше функцию `fcorrs()` в предположении, что для любых значений коэффициентов корреляции между переменными можно получить нужную матрицу переменных (что на самом деле не так), но считая, что с функцией может работать несознательный пользователь, который будет вытворять безобразия -- указывать в векторе корреляций значения, превышающие по модулю 1. В связи с последним, в случае, если функции на вход подается вектор корреляций, содержащий значения, выходящие за рамки \[-1,1\], функция выводит на экран сообщение "The vector of correlation coefficients contains inappropriate values." и больше ничего не делает.

**Продвинутый вариант (на 9-10 баллов).** Написать указанную выше функцию `fcorrs()`

1.  Во-первых, в предположении, что с функцией может работать несознательный пользователь. В связи с последним, в случае, если функции на вход подается вектор корреляций, содержащий значения, выходящие за рамки \[-1,1\], функция выводит на экран сообщение "The vector of correlation coefficients contains inappropriate values" и больше ничего не делает.

2.  Во-вторых, с учетом того, что не для любых значений коэффициентов корреляции между переменными можно получить нужную матрицу переменных -- корреляционная матрица должна быть неотрицательно определена (определитель матрицы должен быть больше или равен 0). В случае, если созданная по заданному вектору коэффициентов корреляций корреляционная матрица отрицательно определена, функция `fcorrs()` должна делать следующее:

-   выводить на экран сообщение "Matrix of correlations is not positive definite. Trying to find the nearest positive definite matrix.";
-   в качестве корреляционной матрицы брать ближайшую положительно определенную матрицу (функция `nearPD()` из библиотеки Matrix), выводить на экран старые (поданные пользователем на вход) значения коэффициентов корреляций с пометкой `Old values of correlation coefficients`, выводить на экран новые (из ближайшей положительно определенной матрицы) значения коэффициентов корреляций с пометкой `New values of correlation coefficients`, выводить на экран [норму Фробениуса](http://mathworld.wolfram.com/FrobeniusNorm.html) для разности исходной (неправильной) корреляционной матрицы и новой (правильной) матрицы с пометкой "Frobenius norm of matrix difference";
-   выдавать матрицу переменных, полученную на основе заданного пользователем вектора средних значений и ближайшей положительно определенной корреляционной матрицы.

*Пример.*

``` r
F <- fcorrs(n_obs = 100, means_vect = c(2, 5, 7), corrs_vect = c(0.3, 0.4, -0.8))
```

    ## Matrix of correlations is not positive definite. Trying to find the nearest positive definite matrix. 
    ## Old values of correlation coeffs: 0.3 0.4 -0.8 
    ## New values of correlation coeffs: 0.2843482 0.3837501 -0.7761998 
    ## Frobenius norm of matrix difference: 0.04637858

``` r
head(F)
```

    ##            [,1]     [,2]     [,3]
    ## [1,]  3.0937341 6.353769 6.415080
    ## [2,] -0.3572004 1.919156 8.417409
    ## [3,]  3.5617773 4.192694 8.804377
    ## [4,]  0.4378003 5.801622 5.200375
    ## [5,]  1.2141611 5.492333 6.009009
    ## [6,]  2.4222829 5.823135 6.484889
