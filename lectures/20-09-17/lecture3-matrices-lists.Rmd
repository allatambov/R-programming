---
title: "Основы программирования в R"
subtitle: "Лекция 3. Векторы и последовательности, матрицы и списки."
author: "Алла Тамбовцева"
date: '20 сентября 2017 г '
output: html_document
---

## Еще немного про векторы

### Поименованные векторы

Помимо обычных векторов (наборов элементов) в R можно создавать поименованные векторы -- наборы элементов с присвоенными им названиями. Создадим вектор с профилем некоторой страны (id, значение ВВП на душу населения, значения индекса демократии, индекс коррупции):

```{r}
cntr_profile <- c(gdp_pc = 2500, democracy = 4.6, corr_index = 2.1)
```

Посмотрим на структуру полученного вектора:

```{r}
str(cntr_profile)
```
Теперь при обращении к какому-либо элемента вектора R будет выдавать не только его значение, но и название:
```{r}
cntr_profile[2]
```

На практике такие вектора нужны нечасто, но если мы когда-нибудь будем писать свои функции или даже библиотеки, нам может понадобиться, чтобы при выводе элемента на экран R показывал пользователю минимальную информацию об этом элементе.

### Поиск совпадающих значений

Пусть у нас есть вектор p и вектор q, и мы хотим выбрать совпадающие элементы -- вывести на экран те элементы в векторе q, которые есть в p.

```{r}
q <- c(1, 2, 4, 1, 2, 3, 3, 2, 1, 4, 2)
p <- c(1, 2) 

q[q %in% p] # 1 и 2
```
Или наоборот - несовпадающие элементы:
```{r}
q[!q %in% p] # не 1 и 2, ! - отрицание
```

Может возникнуть вопрос: а нет ли более изящного способа находить общие элементы в векторах? Существуют же операции для множеств: пересечение, объединение, разность и другие...Да, в R можно работать с множествами. Например, у нас есть два множества, два вектора A и B:
```{r}
A <- c(1, 9, 7, 12, 0, 5)
B <- c(1, 4, 8, 0, 24)
```
Посмотрим на их пересечение (общие элементы A и B):
```{r}
intersect(A, B)
```
А теперь на объединение (все элементы A и B):
```{r}
union(A, B)
```
На разницу (все элементы A, которых нет в B):
```{r}
setdiff(A, B)
```
**Важно:** Cтоит помнить, что множество -- это вектор без повторяющихся значений. Если в интересующих нас векторах есть повторяющиеся значения, и для нас это имеет значение, то тут надо быть аккуратнее.

Сравним результаты двух операций: нахождения совпадающих элементов в двух векторах с помощью `%in%` и нахождения пересечения множеств с помощью `intersect()`. 
```{r}
v1 <- c(2, 2, 3, 4, 5, 8)
v2 <- c(6, 7, 2, 2, 9, 11)
```
Воспользуемся оператором `%in%`:
```{r}
v1[v1 %in% v2] # выдает два совпадающих значения вектора, две 2
```
Воспользуемся функцией `intersect()`:
```{r}
intersect(v1, v2) # выдает один совпадающий элемент, одну 2, так как v1 и v2 воспринимаются как множества
```

А как вообще выглядит множество в R? Как получить вектор без повторяющихся значений? Для этого есть функция `unique()`:
```{r}
unique(v1)
```

### Векторы из повторяющихся значений

В R можно быстро составить вектор из повторяющихся значений. Например, три раза повторить "Repeat me":
```{r}
rep('Repeat me', 3) 
```
Или три раза повторить вектор с двумя значениями 0 и 1:
```{r}
rep(c(1, 0), 3)
rep(c('Yes','No'), each = 4) # повторить 4 раза каждый элемент вектора
```

### Пропущенные значения

Можно создавать векторы с пропущенными значениями (NAs): 
```{r}
w <- c(0, 1, NA, NA)
w
is.na(w) # проверяем, является ли NA
which(is.na(w)) # возвращаем индексы NAs
```
### Прочие вектора

Кроме того, если нужны векторы особого вида (например, набор букв алфавита или названий месяцев), можно взять уже встроенные в R:
```{r}
letters # буквы английского алфавита
LETTERS # заглавные буквы английского алфавита
month.name # названия месяцев
month.abb # сокращенные названия месяцев
```

## Последовательности

Для создания векторов можно использовать последовательности (для владеющих Python: аналог `range()` и `arange()`, но в отличие от Python, здесь в вектор включаются оба конца). Например, последовательность из целых значений от 0 до 10:
```{r}
0:10 
```
Мы можем сохранить результат в вектор  `my_seq`. 
```{r}
my_seq <- 1:10 # можем сохранить результат в вектор my_seq 
my_seq
```
А вот последовательность из целых начений от 1 до 3 с шагом 0.5:
```{r}
seq(from = 1, to = 3, by = 0.5)
```
Названия параметров можем опускать, если сохраняем их порядок:
```{r}
seq(1, 3, 0.5) 
```

## Mатрицы

### Создание матрицы

Матрицы в R можно создавать разными способами. Выбор способа зависит от того, какую матрицу мы хотим создать: пустую матрицу (чтобы потом заполнять ее нужными значениями) или матрицу, составленную из уже имеющихся значений, например, из векторов. 

Для того чтобы создать пустую матрицу, нужно определить, матрицу какой размерности мы хотим. Размерность матрицы -- число строк и число столбцов в ней. Создадим для начала матрицу $2 \times 3$, состоящую из нулей:

```{r}
M <- matrix(0, nrow = 2, ncol = 3)
M
```
Можем посмотреть на ее размерность:
```{r}
dim(M)
```

Заполнять эту матрицу другими значениями мы пока не будем -- это будет интереснее делать, когда мы узнаем про циклы. А сейчас посмотрим, как собрать матрицу из "готовых" векторов.   
Пусть у нас есть три вектора
```{r}
x <- c(1, 2, 3, 0)
y <- c(4, 5, 6, 0)
z <- c(7, 8, 9, 0)
```
и мы хотим объединить их в матрицу. Векторы будут столбцами матрицы:

```{r}
M_cols <- cbind(x, y, z) # c - от columns
M_cols
```

А теперь векторы будут строками матрицы:
```{r}
M_rows <- rbind(x, y, z) # r - от rows
M_rows
```
Другой способ создавать матрицы - разбивать на строки один длинный вектор. Возьмем вектор:
```{r}
long_vec <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 5, 0)
```

Посиотрим, сколько в нем элементов: 

```{r}
length(long_vec)
```
А теперь превратим вектор в матрицу из трех строк и четырех столбцов:

```{r}
m1 <- matrix(long_vec, 3, 4) # получим матрицу с 3 строками и 4 столбцами
m1
```
Конечно, если бы потребовали от R невозможное -- матрицу, произведение числа строк и столбцов которой не равно длине вектора, из которого мы пытаемся эту матрицу создать -- мы бы получили ошибку:
```{r}
# m2 <- matrix(long_vec, 4, 5)
```

Столбцам и строкам матрицы можно дать названия. Посмотрим еще раз на матрицу m1:
```{r}
m1
```

А теперь дадим столбцам этом матрицы названия.
```{r}
colnames(m1) <- c("A", "B", "C", "D")
m1
```
А теперь назовем строки матрицы:
```{r}
rownames(m1) <- c("r1", "r2", "r3")
m1
```

Можно, конечно, присваивать названия сразу и строкам, и столбцам. Проделаем это с матрицей M_cols.
```{r}
dimnames(M_cols) <- list(c("r1", "r2", "r3", "r4"), c("X", "Y", "Z")) # сначала названия строк, затем -- столбцов
```

О том, что такое list -- поговорим чуть позже. 

### Элементы матрицы

Для того, чтобы обратиться к элементу матрицы, необходимо указать строку и столбец, на пересечении которых он находится:
```{r}
m1[1, 3] 
m1[1, ] # вся первая строка
m1[, 2] # весь второй столбец
```

## Списки

Список предсталяет собой "вектор векторов" в терминах R. Для тех, кто знаком с программированием, может показаться, что списки похожи на массивы. Это так, но списки, в отличие от массивов, могут содержать элементы разных типов. Например, в списке может быть сохранен вектор имен студентов (текстовый, тип character) и вектор их оценок (целочисленный, тип integer).

Пример списка с числовыми значениями:
```{r}
L <- list(c(1, 2, 3, 4), c(5, 6, 7, 8))
L
```
А вот пример списка с элементами разных типов:
```{r}
grades <- list(c("Ann", "Sam", "Tom"), c(8, 7, 5))
grades
```
Так как в списках может храниться большое число разных векторов, для удобства им можно давать названия. Список grades можно было записать и так:
```{r}
grades <- list(names = c("Ann", "Sam", "Tom"), marks = c(8, 7, 5))
```
И тогда отдельные вектора из списка можно было бы вызывать удобным образом:
```{r}
grades$names # имена
grades$marks # оценки
```
И если мы бы запросили у R структуру этого списка, мы бы увидели названия векторов, которые в него входят. 
```{r}
str(grades)
```
Можно подумать: зачем нужно знать про списки, если на практике мы обычно будем сталкиваться с другими объектами -- базами данных? На самом деле, со списками мы тоже будем встречаться. Многие статистические функции выдают результат в виде списков. Когда результаты выводятся на экран, это не всегда заметно, но если мы захотим заглянуть внутрь, то увидим, что та же регрессионная выдача представляет собой объект, похожий на список, из которого можно выбрать вектор коэффициентов (coefficients), вектор остатков (residuals), предсказанных значений (fitted.values) и так далее.

А как обращаться к элементам списка, если вектора в нем никак не названы?

Для обращения к элементам списка необходимо использовать двойные квадратные скобки:
```{r}
L
L[[1]] # первый элемент списка, вектор (1,2,3,4)
```
Если нужно обратиться к "элементу элемента" списка (например, к числу 8 в этом примере) нужно сначала указывать номер вектора, в котором находится элемент, а потом номер самого элемента в этом векторе.
```{r}
L[[2]][4] # 8 - 4ый элемент 2ого вектора в списке
```
Можно заметить, что список похож на матрицу: для того, чтобы обратиться к элементу, нужно указать "строку" (вектор) и "столбец" (положение в векторе). 

Для того, чтобы добавить элемент в список, нужно четко понимать положение элемента в этом списке: будет ли это элементом самого массива или "элементом элемента":
```{r}
L
L[[3]] <- c(8, 9) # добавили в список третий вектор
L
L[[3]][3] <- 0 # добавили третий элемент третьего вектора в списке  
L
```
Аналогичным образом можно изменять элементы массива:
```{r}
L[[1]][1] = 99 # заменим 1 элемент 1 вектора в массиве на 99
L
```
Если в списке всего один элемент, при необходимости его можно быстро превратить в обычный вектор с помощью `unlist()`:
```{r}
small_L <- list(c("a", "b", "c"))
small_L
small_vec <- unlist(small_L)
small_vec
```
То же можно делать и с массивами с несколькими элементами, тогда все склеится в один длинный вектор:
```{r}
L
unlist(L)
```
