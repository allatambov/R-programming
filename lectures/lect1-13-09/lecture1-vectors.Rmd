---
title: "Основы программирования в R"
subtitle: "Лекция 1. Векторы в R."
author: "Алла Тамбовцева"
date: '13 сентября 2017 г '
output:
  html_document:
    toc: true
    theme: united
---

### Bекторы

Вектор -- список некоторых объектов. Создается он следующим образом:

```{r}
x <- c(1, 0, 0, 2) # вектор x
```

Можем на него посмотреть:

```{r}
x
```

Определить его тип:

```{r}
class(x)
```

И длину -- число элементов в векторе:

```{r}
length(x)
```
С числовыми векторами в R мы можем осуществлять те же операции, что и с векторами в математике. Но результаты не всегда совпадают. Например, обычное умножение векторов с помощью знака `*` не соответствует ни скалярному, ни векторному произведению векторов. Это происходит потому, что арифметические операции с векторами выполняются поэлементно: 

```{r}
x + x # прибавляем к каждому элементу x элемент x
x * x 
3 * x - x
```

Также мы можем "склеивать" векторы, то есть приписывать в конец одного вектора элементы другого:
```{r}
result <- c(x, 2 * x) # склеиваем два вектора
result
```

Возможны векторы и из нечисловых значений:
```{r}
names <- c("Ann", "Tom", "Jane") 
```
**Внимание:** если в векторе встречаются как числовые значения, так и текстовые, то R будет воспринимать весь вектор как текстовый!
```{r}
mix <- c(1, "Ann", 0, "Jane")
class(mix)
```
При работе с данными нужно всегда внимательно относиться к типу объектов. Например, если у нас есть результаты опроса студентов, и мы видим, что пять респондентов не указали свой возраст, не стоит кодировать эти пропущенные значения словом "нет". Лучше оставить значения пропущенными или закодировать их заведомо невозможным значением (например, 1000), чтобы потом ответы этиих респондентов спокойно отфильтровать. Социологи так обычно и поступают: ответы на вопросы кодируются небольшими числами (например, от 1 до 6, от 1 до 10), а пропущенные значения кодируются числами 98 или 99.


Не всегда числа в векторе являются количественными показателями. C помощью чисел можно кодировать качественную информацию, например, пол респондента: цифра 1 будет обозначать респондентов мужского пола, а цифра 2 - респондентов женского пола. 
```{r}
gender <- c(1, 1, 2, 1, 2, 2, 1)
```

В таком случае часто бывает нужно, чтобы R воспринимал значения не как числа, а как качественную информацию, то есть точно так же, как он воспринимал бы вектор со словами "male" и "female". Для этого можно воспользоваться `factor()`:
```{r}
g <- factor(gender)
g
class(g)
```
У "факторных" векторов всегда есть уровни (Levels) - уникальные значения, с помощью которых кодируются качественные переменные. Здесь есть два "уровня" - "мужской пол" и "женский пол", которые закодированы 1 и 2.

```{r}
str(g) # структура вектора g
```

Преобразование числовых векторов/переменных в "факторные" иногда оказывается очень важным. Например, при подготовки данных перед построением некоторых графиков для качественных переменных или при включении качественной переменной в регрессионную модель. 

### Преобразование типов

Как и у обычных переменных, у векторов можно изменять тип (тип всех элементов вектора). Например, можем преобразовать текстовый вектор в числовой с помощью функции `as.numeric()`:

```{r}
text <- c("2", "3", "5")
as.numeric(text)
```

При этом, если среди элементов есть дробное число, записанное, как текст, то все элементы вектора преобразуются в дробные числа:

```{r}
as.numeric(c("2.3", "6", "8"))
```
Грустная новость: если бы в "2.3" разделителем являлась запятая, ничего бы не получилось -- R в качестве разделителя разрядов признает только точку:
```{r}
old <- c("2,3", "6", "8")
as.numeric(old)
```

Что делать? В таком случае нужно сначала заменить запятую на точку с помощью `gsub()`, а уже потом преобразовывать: 

```{r}
new <- gsub(",", ".", old) # (что заменям, на что заменяем, где заменяем) 
as.numeric(new)
```


### Работа с элементами вектора

Для того, чтобы выбрать элементы вектора по их индексу (положению в векторе), нужно учитывать, что в R нумерация начинается с 1, а не с 0.

```{r}
names
names[1] # первый элемент вектора names
names[0] # не работает
names[1:2] # первые два элемента вектора names
```

А теперь мы будем отбирать элементы вектора по их значению. Для этого необходимо указывать интересующие критерии выбора (условия) в квадратных скобках. Создадим вектор v:
```{r}
v <- c(1, 8, 9, 2, 3, 0, -1)
v
```
Выберем элементы вектора v, которые больше 3:
```{r}
v[v > 3] 
```
Усложним задачу. Будем выбирать только четные элементы вектора v. Для этого нам понадобится оператор для определения остатка от деления: `%%`. Четные элементы -- те, которые делятся на 2 без остатка. Значит, остаток от деления их на 2 должен быть равен нулю:

```{r}
v[v%%2 == 0] # только четные элементы
```

Условия можно сочетать:

```{r}
v[v > 3 & v%%2 == 0] # четные элементы больше 3 
```

Иногда нам нужно не найти элемент вектора по его номеру или по определенным критериям, а выполнить обратную задачу: вернуть индекс элемента (его порядковый номер в векторе). Это можно сделать так:

```{r}
names
which(names =='Jane') # двойной знак =
```
Можно также получать индексы элементов вектора, которые удовлетворяют определенным условиям:
```{r}
v
which(v > 3)
which(v%%2 == 0) # индексы четных чисел
```

А как быть, если мы хотим изменить вектор? Например, добавить значение? Все просто:

```{r}
p <- c(1, 2)
p[3] = 7 # добавим третий элемент
p
```
**Полезный факт:** Индекс последнего элемента вектора в R совпадает с длиной вектора.

Если нужно удалить элемент, это делается так:
```{r}
v[v != 8] # хотим убрать 8
```
Это работает и тогда, когда в векторе встречаются повторяющиеся значения -- убираются все совпадающие элементы:
```{r}
w <- c(6, 6, 6, 7)
w[w != 6]
```

Замена элементов:
```{r}
s <- c('yes', 'no', 'yes', 'yes', 'no') 
```

Хотим заменить 'yes' на 1, 'no' -- на 0 и сохранить все в тот же вектор s.
```{r}
s <- replace(s, s == 'yes', 1) # (вектор, что заменяем, на что заменяем)
s <- replace(s, s == 'no', 0)
s # только вектор по-прежнему текстовый!
s <- as.numeric(s) # теперь все в порядке
s
```

### Сортировка и ранжирование

**Сортировка**

Создадим вектор l и отсортируем его по возрастанию (от меньшего к большему):
```{r}
l <- c(4, 5, 1, 9, 0, 2, 2)
sort(l)
```
А теперь по убыванию:
```{r}
sort(l, decreasing = TRUE) 
```

**Ранжирование**

**Напоминание про ранги.** Если в векторе нет повторяющихся значений, то ранг элемента -- его индекс в векторе, упорядоченном по возрастанию. Если есть, то ранг -- среднее арифметическое индексов этих повторяющихся значений в упорядоченном по возрастанию векторе. Как видно из предыдущего примера, если упорядочим вектор l по возрастанию, 2 стоит на третьем и четвертом местах. Соответственно, ранг 2 будет $(3+4)/2 = 3.5$. Проверим:
```{r}
rank(l) 
```
