---
title: "Основы программирования в R"
subtitle: "Лекция 3. Векторы и последовательности."
author: "Алла Тамбовцева"
date: '20 сентября 2017 г '
output: html_document
---

## Еще немного про векторы

### Поименованные векторы

Помимо обычных векторов (наборов элементов) в R можно создавать поименованные векторы -- наборы элементов с присвоенными им названиями. Создадим вектор с профилем некоторой страны (id, значение ВВП на душу населения, значения индекса демократии, индекс коррупции):

```{r}
cntr_profile <- c(id = 10, gdp_pc = 2500, democracy = 4.6, corr_index = 2.1)
```

Посмотрим на структуру полученного вектора:

```{r}
str(cntr_profile)
```
Теперь при обращении к какому-либо элемента вектора R будет выдавать не только его значение, но и название:
```{r}
cntr_profile[2]
```

На практике такие вектора нужны нечасто, но если мы когда-нибудь будем писать свои функции или даже библиотеки, нам может понадобиться, чтобы при выводе элемента на экран R показывал пользователю минимальную информацию об этом элементе.

### Поиск совпадающих значений

Пусть у нас есть вектор p и вектор q, и мы хотим выбрать совпадающие элементы -- вывести на экран те элементы в векторе q, которые есть в p.

```{r}
q <- c(1, 2, 4, 1, 2, 3, 3, 2, 1, 4, 2)
p <- c(1, 2) 

q[q %in% p] # 1 и 2
```
Или наоборот - несовпадающие элементы:
```{r}
q[!q %in% p] # не 1 и 2, ! - отрицание
```

Может возникнуть вопрос: а нет ли более изящного способа находить общие элементы в векторах? Существуют же операции для множеств: пересечение, объединение, разность и другие...Да, в R можно работать с множествами. Например, у нас есть два множества, два вектора A и B:
```{r}
A <- c(1, 9, 7, 12, 0, 5)
B <- c(1, 4, 8, 0, 24)
```
Посмотрим на их пересечение (общие элементы A и B):
```{r}
intersect(A, B)
```
А теперь на объединение (все элементы A и B):
```{r}
union(A, B)
```
На разницу (все элементы A, которых нет в B):
```{r}
setdiff(A, B)
```
**Важно:** Cтоит помнить, что множество -- это вектор без повторяющихся значений. Если в интересующих нас векторах есть повторяющиеся значения, и для нас это имеет значение, то тут надо быть аккуратнее.

Сравним результаты двух операций: нахождения совпадающих элементов в двух векторах с помощью `%in%` и нахождения пересечения множеств с помощью `intersect()`. 
```{r}
v1 <- c(2, 2, 3, 4, 5, 8)
v2 <- c(6, 7, 2, 2, 9, 11)
```
Воспользуемся оператором `%in%`:
```{r}
v1[v1 %in% v2] # выдает два совпадающих значения векторов, две 2
```
Воспользуемся функцией `intersect()`:
```{r}
intersect(v1, v2) # выдает один совпадающий элемент, одну 2, так как v1 и v2 воспринимаются как множества
```

А как вообще выглядит множество в R? Как получить вектор без повторяющихся значений? Для этого есть функция `unique()`:
```{r}
unique(v1)
```

### Векторы из повторяющихся значений

В R можно быстро составить вектор из повторяющихся значений. Например, три раза повторить "Repeat me":
```{r}
rep('Repeat me', 3) 
```
Или три раза повторить вектор с двумя значениями 0 и 1:
```{r}
rep(c(1, 0), 3)
rep(c('Yes','No'), each = 4) # повторить 4 раза каждый элемент вектора
```

### Пропущенные значения

Можно создавать векторы с пропущенными значениями (NAs, от "not applicable"): 
```{r}
w <- c(0, 1, NA, NA)
w
is.na(w) # проверяем, является ли NA
which(is.na(w)) # возвращаем индексы NAs
```
Обратите внимание: NA указывается без кавычек! Это не текст, который кодирует пропущенные значения, а особый "вид" данных (наличие NA не изменяет тип переменной, то есть, если NA встречаются в числовой переменной, переменная будет восприниматься R как числовая).

### Прочие вектора

Кроме того, если нужны векторы особого вида (например, набор букв алфавита или названий месяцев), можно взять уже встроенные в R:
```{r}
letters # буквы английского алфавита
LETTERS # заглавные буквы английского алфавита
month.name # названия месяцев
month.abb # сокращенные названия месяцев
```

## Последовательности

Для создания векторов можно использовать последовательности (для владеющих Python: аналог `range()` и `arange()`, но в отличие от Python, здесь в вектор включаются оба конца). Например, последовательность из целых значений от 0 до 10:
```{r}
0:10 
```
Мы можем сохранить результат в вектор  `my_seq`. 
```{r}
my_seq <- 1:10 # можем сохранить результат в вектор my_seq 
my_seq
```
А вот последовательность из целых начений от 1 до 3 с шагом 0.5:
```{r}
seq(from = 1, to = 3, by = 0.5)
```
Названия параметров можем опускать, если сохраняем их порядок:
```{r}
seq(1, 3, 0.5) 
```