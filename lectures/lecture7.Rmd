---
title: "Основы программирования в R"
author: "Алла Тамбовцева"
date: '1 ноября 2017 г '
output: html_document
---

## Распределение количественных показателей и проверка распределения на нормальность 

Сравнить распределение с нормальным распределением. Конечно, проверять, является ли распределение некоторого показателя нормальным, можно формально, с помощью специальных статистических критериев (и часто так и нужно), но иногда хочется чего-то более наглядного. Например, наложить на гистограмму, построенную для показателя, график плотности нормального распределения с соответствующими параметрами. 

**Напоминание 1.** О графике плотности распределения можно думать как о "сглаженной" гистограмме (с большим числов столбцов). 

```{r}
x <- sample(seq(1, 200), 100) # показатель x
hist(x) # гистограмма
plot(density(x)) # график плотности
```

**Напоминание 2.** Нормальное распределение задается двумя параметрами: математическим ожиданием (средним значением) и стандартным отклонением. Математическое ожидание отвечает за среднее значение распределения, (значение, относительно которого симметричен график распределения), стандартное отклонение -- за разброс значений вокруг среднего.

```{r}
# add = TRUE - чтобы добавлять графики к уже нарисованным

curve(dnorm(x, mean = 2, sd = 1), xlim = c(-10, 10))
curve(dnorm(x, mean = -1, sd = 1), xlim = c(-10, 10), col = "blue", add = TRUE)
curve(dnorm(x, mean = 2, sd = 3), xlim = c(-10, 10), col = "red", add = TRUE)
```

Теперь попробуем совместить на графике гистограмму и график плотности нормального распределения с соответствующими параметрами. Загрузим базу данных с прошлого занятия.

```{r}
library(foreign)
df <- read.dta("CPDS.dta")

library(dplyr)
df <- df %>% filter(year >= 2014) # выберем данные 
```

Построим гистограмму для показателя *vturn* (явка на выборы) и наложим на нее график плотности нормального распределения с соответствующими параметрами. Какие параметры считать соответствующими? Среднее значение равное среднему значению показателя vturn и стандартное отклонение равное стандартному отклонению vturn.

```{r}
# freq = FALSE - обязательно, так как нужны не частоты, а вероятности
hist(df$vturn, main = "Histogram of turnout", freq = FALSE, col = "tomato")

# na.rm = TRUE - не учитываем пропуски (NA)
curve(dnorm(x, mean = mean(df$vturn, na.rm = TRUE), sd = sd(df$vturn, na.rm = TRUE)), col = "blue", add = TRUE)
```

А теперь проверим формально.

Один из статистических критериев, позволяющих проверить нормальность распределения данных, это **критерий Шапиро-Уилка**. С помощью этого критерия проверяется нулевая гипотеза, которая состоит в том, что *данные распределены нормально*.

```{r}
shapiro.test(df$vturn)
```

Интерпретация

## Связи между качественными переменными: таблицы сопряженности и критерий хи-квадрат

С таблицами сопряженности мы уже знакомы. Построим таблицу сопряженности (contingency table) для двух признаков: 

```{r}
ctab <- table(df$poco, df$gov_party)
```

Визуализируем с помощью мозаичного графика:

```{r}
library(vcd)
mosaic(poco ~ gov_party, data = df)

ang_labels <-  c(0, 0, 0, 0, 0) # углы 
pos_labels = rep("right", 5) # позиции лейблов (названий) 
args = list(set_varnames = c(poco = "", gov_party = "")) # убрать подписи к осям
mosaic(poco ~ gov_party, data = df, rot_labels = ang_labels, just_labels = pos_labels,
       labeling_args = args)

```

А теперь проверим формально, есть ли связь между этими признаками. Воспользуемся критерием хи-квадрат. Нулевая гипотеза: *признаки не связаны (независимы)*.

```{r}
chisq.test(table(df$poco, df$gov_party))
```

## Связи между количественными переменными: диаграммы рассеяния и коэффициенты корреляции

**Диаграммы рассеяния (scatterplots)**

Допустим, мы хотим посмотреть на связь между переменными gov_left1 и gov_left2. Построим диаграмму рассеяния (scatterplot).

```{r}
plot(df$gov_left1, df$gov_right1)
```

Как можно заметить, особой красотой этот график не отличается. График скучный. Что мы можем сделать? Во-первых, подписать оси.

```{r}
plot(df$gov_left1, df$gov_right1, 
     xlab = "Left parties (% of total)", ylab = "Right parties (% of total)")
```

Во-вторых, мы можем добавить цвета, причем вполне содержательно. Допустим, мы хотим разделить страны на пост-коммунистические и не пост-коммунистические и отразить это на графике. То есть, точки, соответствующие пост-коммунистическим странам и точки, соответствующие всем остальным странам будут отличаться по цвету.

```{r}
str(df$poco) # проверим, какие значения принимает poco

colors <- c("blue", "red")[df$poco] # устанавливаем цвета по группирующей переменной

plot(df$gov_left1, df$gov_right1, 
     xlab = "Left parties (% of total)", ylab = "Right parties (% of total)",
     col = colors, lwd = 2)
```

**Матрица диаграмм рассеяния (scatterplot matrix)**

Иногда в ходе предварительного анализа бывает нужно посмотреть на связь “всего со всем”. Для этого удобно использовать матрицу графиков.

Построим диаграммы рассеяния для процентов голосов за разные партии.

```{r}
pairs(df[10:12], col = col) # выбираем столбцы 10-12
```

А теперь более красочно. Но для этого потребуется библиотека car.

```{r}
# install.packages("car")
library(car)

# diagonal - что стоит на диагонали
# smooth = FALSE - обычная регрессия, 
# smooth = TRUE - lowess регрессия

scatterplotMatrix(df[10:12], diagonal = "histogram", smooth = FALSE)
```

```{r}
# создадим вектор с названиями переменных

labs = c("right", "center", "left")

# reg.line = FALSE - нет регрессионной прямой, оставим только smooth (lowess curve)
# var.labels - названия переменных на диагонали
# cex.labels - размер шрифта для labels
# main - название графика

scatterplotMatrix(df[10:12], diagonal = "histogram", smooth = TRUE, 
                  reg.line = FALSE, 
                  var.labels = labs, 
                  cex.labels = 1.3, 
                  main = "Correlations of parties' share")
```

Еще один вариант красивого графика для корреляций - разноцветный график, созданный с помощью пакета gclus.

```{r}
library(gclus)

# получим вектор коэффициентов (по модулю)
coeffs <- abs(cor(df[10:12])) 

# зададим цвета (автоматическое разбиение по вектору коэффициентов)
colors <- dmat.color(coeffs) 

# отсортируем так, чтобы графики, где связь переменных наибольшая,
# были ближе к диагонали

order <- order.single(coeffs)

# строим сам график

# gap - расстояние между графиками в матрице

cpairs(df[10:12], order, panel.colors = colors, gap = .5,
       main = "Correlations of " )
```


**Корреляционный анализ**

Для начала посмотрим на корреляцию каких-нибудь двух переменных:

```{r}
cor(df$gov_left1, df$gov_right1)
```

```{r}
cor(df$gov_left1, df$gov_right1, use = "complete.obs") # использовать все, кроме NA (complete observations)
```

Как известно, существуют разные коэффициенты корреляции. Самые распространенные - линейный коэффициент корреляции Пирсона, коэффициент ранговой корреляции Спирмена и коэффициент ранговой корреляции Кендалла. По умолчанию считается коэффициент Пирсона, остальные можно получить, прописав дополнительный аргумент:

```{r}
cor(df$gov_left1, df$gov_right1, method = "spearman")
```

Проверить значимость:

```{r}
corr <- cor.test(df$gov_left1, df$gov_right1)

coeff <- corr$estimate
pvalue <- corr$p.value

coeff; pvalue
```

Если хотим посмотреть на корреляцию “всего со всем”, можем указать столбцы в базе (переменные) и получить корреляционную матрицу:

```{r}
cor(df[10:12])
```

Матрицу со значимостью:

```{r}
library(Hmisc)
rcorr(as.matrix(df[10:12]))
```

http://www.sthda.com/english/wiki/elegant-correlation-table-using-xtable-r-package

```{r}
install.packages("xtable")

source("correlation.R")
corstars(x = df[10:12], method = "pearson", removeTriangle = "upper", 
         result = "html", file = "corrtable.htm")
```



