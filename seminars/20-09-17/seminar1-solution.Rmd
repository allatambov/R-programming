---
title: "Семинар 1. Векторы, матрицы, списки."
subtitle: "Решения."
author: "Алла Тамбовцева"
date: '20 сентября 2017 г '
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Задание 1

Дан вектор qq:

```{r}
qq <- c(0, 72, 1, 8, 15, 22, 16, 4, 24)
```

-   Сохраните в вектор three элементы вектора qq, которые кратны 3.

```{r}
three <- qq[qq %% 3 == 0]
three
```

-   Сохраните в вектор four элементы вектора qq, которые кратны 4.

```{r}
four <- qq[qq %% 4 == 0]
four
```

-   Сохраните в вектор both элементы вектора qq, которые кратны и 3, и 4.

**Решение 1**

```{r}
both <- qq[qq %% 3 == 0 & qq %% 4 == 0]
both
```
**Решение 2**
```{r}
three[three %in% four] # так
four[four %in% three] # или так
```
**Решение 3**

Решение подходит для данного случая, но оно не является общим: `intersect` - операция для работы с множествами, а множества не содержат повторяющихся элементов.

Если бы нас интересовало число элементов qq, кратных 3 и 4, и среди них
были бы повторяющиеся значения, то функция `intersect` бы нам не подошла -- 
она бы убрала все повторяющиеся элементы. 
```{r}
both <- intersect(three, four)
both
```

-   Создайте вектор all -- припишите в конец вектора three вектор four.
```{r}
all <- c(three, four)
all
```
**Внимание:** функция `union` для множеств нам здесь не подойдет -- она уберет совпадающие значения. 

Сравните:
```{r}
c(three, four) # верно
```
```{r}
union(three, four) # неверно
```

-   Выведите на экран элементы вектора qq, которых нет в векторе all.

**Решение 1**
```{r}
qq[!qq %in% all]
```

**Решение 2**

Решение подходит для данного случая, но оно не является общим: `setdiff` - операция для работы с множествами, а множества не содержат повторяющихся элементов.
```{r}
setdiff(qq, all)
```

## Задание 2

1.  Поставьте библиотеку [randomNames](https://cran.r-project.org/web/packages/randomNames/randomNames.pdf). Обратитесь к ней через `library()`.
```{r, eval=FALSE}
install.packages("randomNames")
```
```{r}
library(randomNames)
```
2.  Создайте вектор из 100 испанских имен:

```{r}
set.seed(1234) # чтобы у всех получались одинаковые результаты
names <- randomNames(100, which.names = "first", ethnicity = 4) 
```

1.  Будем считать, что эти 100 имен -- имена опрошенных респондентов. Создайте вектор со значениями возраста респондентов:

```{r}
ages <- sample(16:75, 100, replace = TRUE) # replace = TRUE - с повторяющимися значениями
```

А также вектор polit -- политические взгляды респондентов:

```{r}
views <- c("right", "left", "moderate", "indifferent")
polit <- sample(views, 100, replace = TRUE)
```

Теперь, когда у нас есть, с чем работать, можно выполнить задание.

-   Определите тип каждого вектора.
```{r}
class(names)
class(ages)
class(polit)
```

-   Создайте вектор id с номерами респондентов.
```{r}
id <- 1:100
```

-   Определите, сколько среди респондентов людей в возрасте от 25 до 30 лет (включительно). Определите, какую долю респондентов в нашей сымпровизированной выборке составляют люди в возрасте от 25 до 30 лет. Выразите эту долю в процентах, округлите ее до 1 знака после запятой.

**Подробное решение**
```{r}
resp <- ages[ages >= 25 & ages <= 30]
length(resp)

share <- length(resp)/length(ages)
round(share * 100, 1)
```
**Все сразу**
```{r}
length(ages[ages >= 25 & ages <= 30])
round(length(resp)/length(ages) * 100, 1)
```

-   Создайте "факторный" вектор политических взглядов polit\_views. Сколько у полученного фактора уровней?

```{r}
polit_views <- factor(polit)
str(polit_views) # 4 уровня
```

-   Создайте матрицу M, столбцами которой являются векторы names, ages, polit\_views. Переименуйте столбцы как Name, Age и Polit. Назовите строки матрицы в соответствии с вектором id.
```{r}
M <- cbind(names, ages, polit_views)
colnames(M) <- c("Name", "Age", "Polit")
rownames(M) <- id
head(M) # посмотрим на первые несколько строк матрицы
```


## Задание 3

В R есть функция `strsplit()`, которая позволяет разбивать строки (текстовые переменные) на части по определенным символам.

Пусть у нас есть строка s:

```{r}
s <- "a,b,c,d"
```

Мы хотим получить из нее вектор из 6 букв. Применям функцию:

```{r}
let <- strsplit(s, ",")
```

Получили почти то, что хотели. Почему почти? Потому что получили не вектор, а список!

```{r}
class(let)
```

Превратим в вектор:

```{r}
unlist(let)
```

Теперь все в порядке, получили вектор из четырех элементов.

Теперь задание. Дана строка index:

```{r}
index <- "0,72;0,38;0,99;0,81;0,15;0,22;0,16;0,4;0,24"
```

Получите из этой строки числовой вектор I.

**Подробное решение**
```{r}
l <- strsplit(index, ";") # разбиваем по точке с запятой
v_comma <- unlist(l) # превращаем в вектор
v_dot <-gsub(",", ".", v_comma) # заменяем запятую на точку - иначе не превратим в числовой вектор
I <- as.numeric(v_dot)
I
```
**Всё сразу**
```{r}
I <- as.numeric(gsub(",", ".", unlist(strsplit(index, ";"))))
```

## Задание 4

Создайте из векторов из задания 2 список resp.
```{r}
resp <- list(names, ages, polit)
```
-   Выведите на экран первый элемент списка resp.
```{r}
resp[[1]]
```

-   Выведите на экран второй элемент третьего вектора в списке resp.
```{r}
resp[[3]][2]
```

-   Измените пятый элемент первого вектора в списке resp.
```{r}
resp[[1]][5] <- "Maria"
resp[[1]]
```


